<! DOCTYPE html><html><head><title>Circular Buffer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"><style>	.margin	{		margin-left:2.5em;		margin-right:2.5em;		margin-top:1em;		margin-bottom:1em;	}</style></head><body class="margin"><h1>Circular Buffer</h1><hr/><h2> Delay of sound, using a circular buffer</h2><p>There are many reasons to want to use a time-delayed copy of a sound: for creating an echo effect, for simulating room reverberation, for filtering (changing the frequency content of a sound), and for a variety of other delay-based effects such as flanging, chorusing, Doppler shift, etc. Let's take a look at the generally-accepted way to delay a sound.</p><p>Audio delay is achieved by simultaneous recording and playback; while we play back recorded sound from the recent past, we keep recording the current sound so that there's always sound to play back. Since we don't have an infinite amount of memory in which to store recorded sound, it makes sense to store a recording only of the most recent time period&mdash;up to the amount of delay we expect to need&mdash;and throw away recorded sound from the more distant past. We do that by recording the newest (current) sound over the oldest (no longer needed) sound in a loop. We record the sound data into an array, and when we reach the end of the array we wrap around to the beginning and continue recording. An array that we treat as a loop in this manner is called a <i>circular buffer</i> or a <i>ring buffer</i>.</p><p>For example, suppose we wanted to store the most recently recorded one second of audio. At an audio sampling rate of 44,100 samples per second, we would need an array with a length of at least 44,100. We'd first set a counter variable <i>n</i> to 0, to point to the beginning of the array. To record, we put the current audio amplitude into array location n, increment n, and 1/44100 of a second later do that again, over and over. When n is determined to be greater than or equal to the length of the array, we wrap n around to stay within the array, and continue.</p><p>Here's some pseudo-code to show that.</p><p><pre>var samplerate = 44100.; // samples per secondvar seconds = 1.; // duration of the buffervar arrayofsamples = new Float32Array( samplerate*seconds ); // create buffervar n = 0; // initialize the counterwhile ( recording ) { // at the sampling rate	arrayofsamples[n] = inputvalue; // store current audio sample	n = (n+1) % arrayofsamples.length; // wrap to stay within the array}</pre></p><p>In order to play back the sound that happened a precise amount of time ago, we need to keep track of the current time. The counter n used in the recording process is always the marker of "the current time" in the array. Some time in the past&mdash;we'll call it <i>d</i>, for delay in samples&mdash;will thus be point <i>n-d</i> in the array. If n-d is less than 0, we'll have to wrap that back into the proper range to stay within the array; as long as d is less than the length of the array, that will still point to the proper time in the past.</p><p>In the <a href="http://music.arts.uci.edu/dobrian/maxcookbook/">Max Cookbook</a> of programming examples, you can find an implementation of a <a href="http://music.arts.uci.edu/dobrian/maxcookbook/diy-ring-buffer">DIY ring buffer</a> in Max/MSP. The MSP object <b>delay~</b> does the same thing with a single object.</p><hr width=50%/><p>This page is by <a href=http://music.arts.uci.edu/dobrian/>Christopher Dobrian</a>, <a href="mailto:dobrian@uci.edu"><i>dobrian@uci.edu</i></a>.<br/>Last modified March 31, 2019.</p></body></html>