So far, we only know how to interact with the *js* object by sending it a bang,
and by writing a corresponding `bang()` function.  We can do the same things
for ints and floats with the `msg_int()` and `msg_float()` functions,
respectively.  These functions take one argument, and this argument will
consist of the integer or float that was sent to the function.  As a dumb
example, let's have our *js* object add 5 to whatever comes in its inlet.
Here's what that code would look like.

	function msg_int(i) {
	  outlet(0, i + 5);
	}

	function msg_float(f) {
	  outlet(0, f + 5);
	}


It turns out these functions are more flexible.  If you send the *js* object a
_list_ of integers, for instance, the `msg_int()` function will still trigger.
Each extra argument you add to the `msg_int` function will correspond to the
next element of the list, and—get this—they don't need to even all be integers,
just the first one.

	outlets = 3;

	function msg_int(i, j, k) {
		outlet(0, i);
		outlet(1, j);
		outlet(2, k);
	}

If you'd rather not refer to each element of the list one-by-one, you can get
all of the arguments at once with the built-in `arguments` variable.  Be
careful though: if you try to print the `arguments` array as is, you'll get a
very unhelpful message that says `jsobject` followed by some integer; this is
actually a pointer to the array, not the array itself.  To see each element of
the array, iterate through it with a `for` loop.

	function msg_int() {
	  post(arguments); // this is totally unhelpful
	  post("\n");
	  var s = ""
	  for (var i = 0; i < arguments.length; i++) {
	    s += arguments[i] + " ";
	  }
	  post(s); // this is much better
	  post("\n");
	}

Finally, it turns out you can send the *js* object _any_ message, as long as you have a corresponding outer-level function of the same name.  Here is yet another dumb example.

